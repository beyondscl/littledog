
点击qq是如何登录到其他第三方的呢？
ajax原理，越深入越好
dojo  	ajax框架
dwr		ajax框架
restapi 
rmi （java内部有）
重构
soa
jetty
activemq
淘宝，qq，微信等接口看看
常用sql，常用函数，较为复杂sql,编写pl/sql
======================================================================================================================================================

虚拟机
jvm 内存模型
       java堆
			线程共享的内存区域
			唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
	   java虚拟机栈
			线程私有的
			或者说是虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型和对象引用
																			（boolean、byte、char、short、int、float、long、double）
	   方法区
				线程共享的内存区域
				用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
			包含运行时常量池
	   本地方法栈
	   程序计数器
			线程私有的
			程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器
jvm垃圾回收机制
	退出，错误，异常为捕获的对象
	标记算法，根查找算法，复制算法等
	jvm优化逃逸

类加载的步骤
		加载、连接/(验证、准备、解析)、初始化、使用和卸载 这7个阶段 
		
	准备
		准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
        public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。

	解析
		直接引用
			数据的物理地址
		符号引用
			在没有运行的时候，一个符号代替真实运行时候的物理地址
			
			解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
				符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，
					只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
				直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
					直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。
	初始化
		类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。
        初始化阶段是执行类构造器<clinit>()方法的过程。<clinit>()方法是由编译器自动 收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的 。
				http://www.tuicool.com/articles/QZnENv
类加载器
	ClassLoader
		1）Bootstrap ClassLoader
		负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类
		2）Extension ClassLoader
		负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包
		3）App ClassLoader
		负责记载classpath中指定的jar包及目录中class
		4）Custom ClassLoader
		属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader
		加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

集合

	网络编程
		socket 没用过，略过
	并发(sync，java.util.concurrent.locks 包下面的类。
				Condition Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。 
				Lock Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。 
				ReadWriteLock 
			)
	线程状态
		新，就绪，（阻塞/休眠/io等待），运行中,结束
		     yield 运行中>就绪 ,让其他高于或等于的优先级的线程运行。
			 sleep 运行中>休眠
			 join 加入当前线程A的尾部，知道A完成
			 对象的wait 知道被唤醒
	

序列化
传输IO
		字节流
		字符流
	NIO 通道，缓冲区
		非阻塞，线程可以一直读取知道完成，当通道没有数据可以读取，他可以拿去写数据。
		
	
	
基础tcp/ip
TCP三次握手链接
	请求连接，
		收到报文，准备空间，返回报文
	收到报文，准备空间，返回报文	
		收到并建立连接
四次挥手释放


数结构
算法分析
七层协议与tcp关系

OSI模型
应用层 http
展现层
会话层
传输层 ipc/udp
网络层 ip
数据链路
物理层

对应上面
****TCP/IP模型
应用层3
传输层1
网际层1
主机至网络层2
=======================
spring面试题


	
===========================================================================================================================================================
集群分布式架构
消息队列
数据等缓存
精通网络编程，能够完成TCP、UDP、HTTP协议的跨协议数据交换，能够开发安全可控的分布式应用，熟悉HTTP协议格式；
熟练掌握Java多线程并发及异步机制，深入了解Java线程锁与信号量等同步工具；

===================================================
1、熟悉Spring、mybatis, 熟悉Linux、JVM调优、GC机制,深厚的理论基础和实践经验
2、精通Java编程基础：集合框架、多线程并发、IO/NIO、网络通信等
3、JAVA基础扎实，熟悉IO、多线程、集合等基础框架，熟悉分布式、缓存、消息、搜索等机制；
4、熟悉常用设计模式，有大型分布式、高并发、高负载、高可用性系统 设计开发经验
5、熟悉消息（ActiveMQ/RabbitMQ）、搜索（lucene/solr/elastic search）、缓存（Redis/Memcached）技术
6、熟悉 Linux 开发环境，掌握常见指令，会写简单的 Shell 脚本
7、有系统架构设计经验并熟悉领域模型设计且有实际项目经验的优先
8、有项目管理经验的优先
9、3年以上JAVA开发工作经验
28++++++++++++++++++++++++++++36
===========================================
了解工作流机制和原理：这个是自己做过项目的核心领悟！！
前提基础要牢靠，不然这个是扯淡！这几个很重要，是求职高薪亮点所在！
熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题；
		什么是分布式
		缓存：客户端缓存、前端页面缓存、页面片段缓存ESI
		Varnish是一款高性能的开源HTTP加速器可以结合ESI
掌握多线程及高性能的设计与编码及性能调优；有高并发应用开发经验； 
	并发数，吞吐量，美妙访问量概念等等
一个操作的具体实现流程，越详细越好
设计模式与领域建模
一种开源框架的原理与核心
常用sql使用与优化
linux脚本命令

常用算法，还有动态的
http://www.myexception.cn/other/1825523.html

秒杀系统的实现


java
    （抽象）
    封装
    继承
    多态
1:策略模式
    封装变化,(单独起来用接口)
    多用组合，少用继承
    针对接口编程，不针对实现编程
    说明:
        类中引用接口，调用接口中的方法
        设置接口用set方法，动态传入接口的具体实现
    =============================
    例子：
      spring中的Sessionfactory   sessionfactory 接口。
      用setSessionfactory（O,o）来动态(比方:你可以任意方式连接数据库)设置参数
      调用接口方法
2:观察者模式
    加+1
    为交互对象的松耦合而设计
    比如界面组件，jbutton
    说明：
        在主题中使用注册和退出方法，实现观察者的添加删除。
        其实就是链表维持观察者的具体实现，调用统一方法，(推送或者提取数据)
        可以设置阀门，就是何时调用统一方法（阀门可以控制调用的频度或者维度更容易扩展）
    =============================
    例子：
        比如订阅读者，读者会定时给你发送杂志。

3:装饰模式
    加1+2
    动态的加行为加载已有的对象上面，适用于需要现有类进行功能扩展
    超类(抽象，接口)
    装饰组件编程，具体子类
    组合：组件与子类；进行想要的各种装饰；装饰者包含各种组件。
    对需要扩展的开放，对修改关闭
    比如：java中的输入输出流等等
    缺点：过度使用，可能会引入很多小类
    =============================
4:工厂模式
    加1,2,3依赖抽象，不要依赖类;
    都是为了松耦合，易扩展
    简单工厂
        把创建对象提取到另外一个类中，客户端代码保留一个引用;代码解耦
    工厂模式
        让子类继承实现自己的抽象方法；专业说法：把类的实例化推迟到子类
        工厂也是实现接口而抽象来，产品也是实现接口而抽象来
    抽象工厂模式
        提供接口，创建相关对象家族，不需要明确指定类
    =============================
5:单例模式
    一般用在处理资源上面
    1静态模式，jvm启动就加载，如果小消耗资源太大，不合适
    2用到在加载。
        判断空后在加载
            多线程中同步方法-->（消耗性能）-->同步为空后的代码块儿，那么只需要同步一次:双重检查枷锁 ;volatile
            让编辑器不忽略该代码必定执行。
    3还有就是用枚举类型
    ！！！！未知：自行指定类加载器
    =============================
6:命令模式
    将请求封装成对象，用请求来参数化其他对象。
    发起者只有一个命令，接收者实现命令打包动作。。发起者和接收者完全的解耦。
    用途 ：可以用于队列，日志记录，数据恢复，事务管理，线程，撤销等等。
    说明：一个命令(可以包含一组命令)，一个命令包含一个对象的引用，可以包括一个对象的一个(一组)操作
    不直接调用对象的方法，虽然很繁琐但是可以达到很大的解耦，但是代码略多。参考：com.dog.designModel.cmd.CmdTest
    =============================
7:适配器和外观模式
    将目标接口转换为需要的接口
    对象适配器
        实现需要的接口，持有目标接口的类
    类适配器:此需要多继承来实现，java不行。
    (双向适配器)
    =============================
    外观模式
        目的:让接口变得更简单
        提供一个接口来访问子系统的一群接口。（相当于封装了一堆方法到一个方法中）
减少耦合：
    最少知识原则（只和朋友交谈）:266页，适用对象.方法，不要建议使用多层对象.方法.方法...
        该对象本身的方法
        该对象组件的方法
        该对象创建的方法
        该对象中方法传入的对象参数中方法
模式原则只是提供一个思路，在某种合适的情况使用，不外乎是时间和空间的平衡！
模式虽大同小易，但是目的性是不一样的。

8:模板方法模式
    目的:提供一个算法模板，让子类去实现某些步骤
    基类中用final固定一个方法（方法中包含其他一系列其他操作），子类可以调用该方法（基类中应该会有抽象方法和钩子）提供模板中必须的方法，固定的步骤完成操作
    比如java中排序算法，看源码中的compareto方法.文件流中一些。
    钩子：类的模板方法中有一个什么都不做(或者提供默认实现)的方法，子类视情况是否覆盖
    好莱坞原则：别找我，我会找你。高层组件可以依赖调用低层组件，但是尽量不要反过来，以免形成环状依赖，比如上面的钩子
    =============================
9:迭代器与组合模式
    提供一个方法访问集合中的各个元素又不 暴露其具体实现(比如： for ( in ))
    针对接口编程，而不是针对每个类。封装变化，减少依赖(解耦)如下这个例子：
        比如需要遍历list和数组，建立一个公共迭代器(不做处理一般是没顺序的,枚举的迭代器是有次序的)。这样只需要一个方法就可以迭代了。
    原则：单一责任。一个类只有一个会引起变化的部分
    内聚：一个类或者一个模块只支持一组相关功能时候，高内聚。当支持一组不太相关的各个功能时候，低内聚。
        用原则来实现类，会好很多。
    随着程序的复杂，我们可能需要重构我们的代码了！
        有时候我们需要折衷来选择平衡性和透明性
    =============================
    组合模式
    允许你将对象组合成树形结构来表现，整体部分层次结构.（提供一种数据结构可以包含一个对象，一组对象）
        组合能让客户用一致的方式来处理个别对象和对象数组。（对一组中的某个特殊对象不需要做if这些特别的判断处理）
    透明性：客户对具体实现和类的类型很明白，能清楚看到你的数据结构
    有时候返回一个没有任意操作意义的同样数据结构，比返回一个不同类型的null。要好点儿。因为不用判断了，对吗？
10:状态模式
    允许对象在内部状态改变时改变它的行为，看起来就是改变了它的类
        将状态封装成类，一个状态一个类。对状态修改关闭，对扩展开发（添加其他的状态类）
     意图：如果你需要在一个类中管理状态，解决一个类中很多很多if的判断，将每个if改为状态
     策略模式意图：除继承之外的弹性解决方案,通过组合来添加行为。
接口与抽象类中的一些意义上的区别：抽象类可以实现一些通用的默认实现来减少代码的重复量
    =============================
11:代理模式 429
    为另外一个类提供一个替身或者占位符来控制这个对象的访问
    比如卖方，找工作，都是不直接和主题对话，先和中间商代理沟通，防火墙，缓存，翻墙，不是吗？
    变种很多
    远程代理
        RMI：JAVA远程方法调用相关方法,jdk版本不一样或许有更新的改变了
                高版本貌似不需要了:(Naming.look
                remote
                rmic工具)
        动态类下载？？？？
     虚拟代理
        (资源消耗大的地方),比如加载图片，由模糊到精细
     动态代理
     保护代理
    =============================
12:复合模式(模式的模式,mvc是四层=ui,pd,si,dm模式的一种具体应用)
    比如mvc;gui的模式到web的模式
13:运用模式
